# script renamed
# Computes the test coverage of vuln_commit with respect to fix_commit's git diff

import os
import subprocess
import glob
import csv
import multiprocessing

# --- HARDCODED CONFIGURATION ---
PROJECT_NAME = "curl"
# The commit where the vulnerability exists (Tests run here)
VULN_COMMIT = "96ffe645fd2494f14780f7c105fcfeeb8ca7d94f" 
# The commit where the fix happened (Used only to identify target source files)
FIX_COMMIT = "2eb8dcf26cb37f09cffe26909a646e702dbcab66" 

PROJECT_BASE_DIR = "ds_projects" # Relative to script dir
RESULTS_DIR = "vfec_results"     # Relative to script dir

# Derived Paths
PROJECT_PATH = os.path.join(PROJECT_BASE_DIR, PROJECT_NAME)
LOG_FILE = os.path.join(RESULTS_DIR, "log", f"vuln_{PROJECT_NAME}_{VULN_COMMIT[:8]}.txt")
OUTPUT_CSV = os.path.join(RESULTS_DIR, "vuln_testcov.csv")

# Silent optimization
CPU_CORES = multiprocessing.cpu_count()

def ensure_dirs():
    """Create necessary results directories if they don't exist."""
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    os.makedirs(os.path.dirname(OUTPUT_CSV), exist_ok=True)

def write_log(message):
    with open(LOG_FILE, "a") as f:
        f.write(message + "\n")

def run_cmd(command, cwd, description, can_fail=False):
    """Executes command. Logs only on failure."""
    try:
        subprocess.run(
            command, shell=True, cwd=cwd, check=True,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        return True
    except subprocess.CalledProcessError as e:
        error_msg = f"ERROR in {description}:\nCmd: {command}\nStderr: {e.stderr}"
        write_log(error_msg)
        if not can_fail:
            print(f"Critical Failure: {description}. Check logs.")
            exit(1)
        return False

def get_target_files_from_fix():
    """
    Checks the FIX_COMMIT to see which .c files were modified.
    These are the files we want to see 'touched' in the VULN_COMMIT.
    """
    print(f"üîç Analyzing FIX_COMMIT {FIX_COMMIT[:8]} to identify target files...")
    cmd = f"git show --name-only {FIX_COMMIT}"
    try:
        result = subprocess.check_output(cmd, cwd=PROJECT_PATH, shell=True, text=True)
        # Filter for .c files only and get basename
        files = [os.path.basename(f) for f in result.splitlines() if f.endswith('.c')]
        return files
    except subprocess.CalledProcessError:
        write_log(f"Failed to get files for fix commit {FIX_COMMIT}")
        return []

def normalize_gcda_name(filename):
    """
    Converts a gcda filename to a likely source filename, 
    handling curl's build prefixes.
    Ex: 'curl-tool_msgs.gcda' -> 'tool_msgs.c'
    """
    if filename.endswith('.gcda'):
        name = filename[:-5]
    else:
        name = filename

    prefixes = ["curl-", "libcurl_la-", "libcurltool_la-"]
    for prefix in prefixes:
        if name.startswith(prefix):
            name = name[len(prefix):]
            break 
            
    return name + ".c"

def get_touched_source_files():
    """Finds all .gcda files generated by the last test run and maps them to .c filenames."""
    gcda_files = glob.glob(f"{PROJECT_PATH}/**/*.gcda", recursive=True)
    
    touched_sources = set()
    for g in gcda_files:
        base_name = os.path.basename(g)
        clean_name = normalize_gcda_name(base_name)
        touched_sources.add(clean_name)
        
    return touched_sources

def main():
    ensure_dirs()
    # Clear log for new run
    with open(LOG_FILE, "w") as f: f.write(f"--- Vuln Test Log for {PROJECT_NAME} ---\n")
    with open(LOG_FILE, "a") as f: f.write(f"Vuln Commit: {VULN_COMMIT}\nFix Commit: {FIX_COMMIT}\n")

    # 1. Identify Target Files (using Fix Commit)
    target_files = get_target_files_from_fix()
    if not target_files:
        print("‚ö†Ô∏è  No .c files found in the fix commit. Cannot proceed.")
        return
    print(f"üéØ Target files (from fix): {target_files}")

    # 2. Switch to Vulnerable Commit and Build
    print(f"üõ†Ô∏è  Phase 1: Building VULN version ({VULN_COMMIT[:8]}) with Coverage...")
    run_cmd("git reset --hard", PROJECT_PATH, "Git Reset")
    run_cmd("git clean -fdx", PROJECT_PATH, "Git Clean")
    run_cmd(f"git checkout {VULN_COMMIT}", PROJECT_PATH, "Git Checkout VULN")
    
    # Build steps (Debug + Coverage + No Optimization)
    run_cmd("./buildconf", PROJECT_PATH, "Buildconf")
    config_flags = (
        '--disable-ldap --without-ssl --disable-shared --enable-debug --enable-maintainer-mode '
        'CFLAGS="-fprofile-arcs -ftest-coverage -g -O0" LDFLAGS="-fprofile-arcs -ftest-coverage"'
    )
    run_cmd(f"./configure {config_flags}", PROJECT_PATH, "Configure")
    
    # Silent use of all cores
    run_cmd(f"make -j{CPU_CORES}", PROJECT_PATH, "Make Main")
    run_cmd("make", os.path.join(PROJECT_PATH, "tests"), "Make Tests")

    # 3. Prepare Test List
    test_data_dir = os.path.join(PROJECT_PATH, "tests/data")
    test_files = sorted(glob.glob(os.path.join(test_data_dir, "test*")))
    test_ids = [os.path.basename(t).replace("test", "") for t in test_files if os.path.basename(t).replace("test", "").isdigit()]

    print(f"üß™ Phase 2: Running {len(test_ids)} tests on VULN commit...")
    
    # Prepare CSV header
    file_exists = os.path.isfile(OUTPUT_CSV)
    with open(OUTPUT_CSV, "a", newline="") as csvfile:
        writer = csv.writer(csvfile)
        if not file_exists:
            writer.writerow(["project", "vuln_commit", "testfile", "sourcefile", "fix_commit"])

        for tid in test_ids:
            # A. Clean previous coverage data
            subprocess.run(f"find . -name '*.gcda' -delete", cwd=PROJECT_PATH, shell=True)
            
            # B. Run Test
            run_cmd(f"./runtests.pl {tid}", os.path.join(PROJECT_PATH, "tests"), f"Test {tid}", can_fail=True)
            
            # C. Check intersection
            touched_files = get_touched_source_files()
            intersection = [f for f in target_files if f in touched_files]

            if intersection:
                for source in intersection:
                    # Output: project, vuln_commit, testfile, sourcefile, fix_commit
                    writer.writerow([PROJECT_NAME, VULN_COMMIT, tid, source, FIX_COMMIT])
                
                print(f"‚úÖ Test {tid} touched target file: {intersection}")

    print(f"üèÅ Finished. Results in {OUTPUT_CSV}")

if __name__ == "__main__":
    main()